<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Velo</title>
    <!-- <base href="/VELO-Image-Size-Optimizer/" /> -->
    <base href="/VELO-Image-Size-Optimizer/" />
    <link href="css/bootstrap/bootstrap.min.css" rel="stylesheet" />
    <link href="css/app.css" rel="stylesheet" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link href="Velo.styles.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&family=Inter:wght@400&display=swap"
        rel="stylesheet">
</head>

<body>
    <div id="app">
    </div>


    <script src="_framework/blazor.webassembly.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        window.veloFileCache = {};

        window.getSelectedFilesInfo = async (inputElement) => {
            const files = inputElement.files;
            const result = [];

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                // Usiamo un ID semplice o il nome + data per evitare problemi di caratteri
                const id = 'file_' + Math.random().toString(36).substr(2, 9);

                // SALVATAGGIO REALE DEL BLOB
                window.veloFileCache[id] = {
                    name: file.name,
                    blob: file // Questo è il Blob richiesto da createImageBitmap
                };

                result.push({
                    fileId: id,
                    name: file.name,
                    size: file.size
                });
            }
            // Non resettiamo l'input file qui - lo farà solo l'utente con un tasto esplicito
            // inputElement.value = '';
            return result;
        };

        window.clearFileInput = (inputElement) => {
            inputElement.value = '';
        };

        window.compressNativeVelo = async (fileId, quality) => {
            const item = window.veloFileCache[fileId];
            if (!item || !item.blob) {
                throw new Error("File non trovato nella cache: " + fileId);
            }

            // Qui passiamo item.blob che è il file originale
            const img = await createImageBitmap(item.blob);

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            const resultBlob = await new Promise(resolve =>
                canvas.toBlob(resolve, 'image/jpeg', quality / 100)
            );

            // Salviamo il blob ottimizzato per lo ZIP futuro
            window.veloFileCache[fileId].optimizedBlob = resultBlob;

            const arrayBuffer = await resultBlob.arrayBuffer();
            return {
                data: new Uint8Array(arrayBuffer),
                url: URL.createObjectURL(resultBlob),
                origSize: item.blob.size
            };
        };

        window.removeFromCache = (fileId) => {
            const item = window.veloFileCache[fileId];
            if (item) {
                // 1. Liberiamo la memoria revocando gli URL creati
                if (item.url) URL.revokeObjectURL(item.url);
                if (item.originalUrl) URL.revokeObjectURL(item.originalUrl);

                // 2. Cancelliamo l'oggetto dalla cache
                delete window.veloFileCache[fileId];

                console.log(`File ${fileId} rimosso dalla memoria.`);
            }
        };

        window.clearVeloCache = () => {
            veloFileCache = [];
        };

        window.downloadAsZip = async (filesJson) => {
            const zip = new JSZip();
            const folder = zip.folder("Velo_Optimized");
            const files = JSON.parse(filesJson);

            for (const file of files) {
                // Decodifichiamo la stringa Base64 o l'array in un Uint8Array
                // Se passiamo l'oggetto da Blazor, i dati arrivano spesso come stringa Base64
                folder.file(file.fileName, file.data, { base64: true });
            }

            const content = await zip.generateAsync({ type: "blob" });
            const zipUrl = URL.createObjectURL(content);

            const link = document.createElement('a');
            link.href = zipUrl;
            link.download = "Velo_Images_Pack.zip";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };


        window.getFileUrl = (fileId) => {
            const item = window.veloFileCache[fileId];
            if (item && item.blob) {
                return URL.createObjectURL(item.blob);
            }
            return "";
        };

    </script>
    <script src="js/preview-zoom.js"></script>
</body>



</html>